在二进制计算中，如果计算结果超过计算机的位数，就会发生溢出。

设机器字长为 `8` 位（包括一位符号位），`A = 15`，`B = -24`，`C = 124`，求 `[A+B]补`、`[A-B]补`、`[A+C]补`、`[B-C]补`

将十进制数转换成二进制机器数
- [A]原 = 00001111，[A]补 = 00001111
- [B]原 = 10011000，[B]补 = 11101000
- [C]原 = 01111100，[C]补 = 01111100

## 加法和减法运算

加法运算，可以直接把两个有符号数的补码进行相加，计算第一个式子：`[A+B]补 = [A]补 + [B]补 = 00001111 + 11101000 = 11110111`，得到 `[A+B]补 = 11110111` 转换成真值为 `-9`，和用十进制计算 `A+B` 的结果一样。

减法运算，是先把它变成加法运算，然后用补码的进行加法运算，计算第二个式子：`[A-B]补 = [A]补 + [-B]补 = 00001111 + 00011000 = 00100111`，得到 `[A-B]补 = 00100111` 转换成真值为 `39`，和用十进制计算 `A-B` 的结果是一样的。

加法运算和减法运算在计算机内部都是加法运算，只是对于减法运算来说，多了一个求相反数的电路：`B` -> `-B`

## 溢出判断

两个机器数，进行了加减运算后，得到的结果和十进制数加减运算后的结果不一致，这就造成了溢出
- `[A+C]补 = [A]补 + [C]补 = 00001111 + 01111100 = 10001011`，真值是 `-11`，十进制 `A+C` 真值是 `139`
- `[B-C]补 = [B]补 + [-C]补 = 11101000 + 10000100 = 01101100`，真值是 `108`，十进制 `B-C` 真值是 `-148`

溢出的几种判断方式：
  - 采用一位符号位
  - 采用一位符号位和数据位进位
  - 采用双符号位

### 采用一位符号位

假设被加数的符号位为 `As`，加数的符号位为 `Bs`，结果位的符号位为 `Ss`

将符号位进行异或运算：`V = AsBs!Ss ⊕ !As!BsSs`
  - 异或运算的原理是相同得到 `0`，不同得到 `1`
    - 如果 `V = 0`，表示无溢出
    - 如果 `V = 1`，表示有溢出

### 采用一位符号位，根据数值位和符号位的进位情况判断溢出

假设数值位的进位为`C1`，符号位最高位进位为 `Cs`

将符号位进行异或运算：`V = C1 ⊕ CS`
  - 异或运算的原理是相同得到 `0`，不同得到 `1`
    - 如果 `V = 0`，表示无溢出
    - 如果 `V = 1`，表示有溢出

### 采用双符号位

存储在计算机内部的二进制数是正确的数据，也就是说不存在溢出的行为，所以采用一位符号位即可，比如 `00001111` 或者 `10001111`。

双符号位就是在单符号位的基础上在添加一位符号位，两位符号位分别记为：`S1`、`S2`。

将符号位进行异或运算：`V = S1 ⊕ S2`
  - 异或运算的原理是相同得到 `0`，不同得到 `1`
    - 如果 `V = 0`，表示无溢出
    - 如果 `V = 1`，表示有溢出

采用双符号位的移位运算
  - 低位符号位参与移位，高位符号位代表真正的符号
  - 使用双符号位的数一般是补码