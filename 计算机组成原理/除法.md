二进制除法和十进制除法是一致的，都是采用：**将被除数从高位除起，每次计算得到的商保留，余数加下一位数再次进行除法，依次将被除数所有位数运算完毕，得到的商按照按顺序组合，余数为最后一次运算结果。**

`[x]原 = 0.1011，[y]原 = 0.1101`
  - 0.1011 ÷ 0.1101 = 0.1101 ... 0.00000111
    - 1011 ÷ 1101 = 0
    - 10110 ÷ 1101 = 0.1 ... 1001
    - 10010 ÷ 1101 = 0.11 ... 0101
    - 01010 ÷ 1101 = 0.110
    - 10100 ÷ 1101 = 0.1101 ... 0.00000111
  - 每做一次除法运算，如果被除数小于除数，商 0，否者商 1，在用余数减去除数，得到下一个被除数，以此循环
  - 符号位进行异或运算：0 ⊕ 0 = 0
  - 最终结果：0.1101，余数是 111

这是我们人类通过除法的竖式计算得到的结果，商 `0` 还是商 `1`，是通过比大小决定的，计算机在做除法的时候总不能凭空比大小吧？还有每次做完除法后，余数的位数也是不确定的。

那计算机该如何实现除法呢？

通过前面的学习，我们知道运算器是由 ACC 、MQ、X、ALU 组成。

ALU 是运算器的核心，计算的功能是由这部分它来完成的。ACC 、MQ、X，它们是用来暂存操作和中间结果，通过指令交由 ALU 处理。

再除法运算中，各寄存器有不同的作用：
  - `ACC`：被除数、余数
  - `MQ`：商
  - `X`：除数

## 原码除法恢复余数法

最终运算结果，商在 `MQ` 中，商的位数是数值位位数；余数在 `ACC` 中，余数的位数是 `2^-n`；运算结果的符号位单独处理：被除数的符号位 ⊕ 除数符号位。

### 运算过程

计算机每次都是商 `1`，如果不对，在改商 `0`，并恢复余数。

如何判断商 `1` 对不对呢？

用**被除数(除数) - 商: `ACC - X` -> `ACC - [y]原` -> `ACC + [-y]补`**，如果余数是负数，则改商 `0`。

由于商错了，所以上一步计算的余数是不对的，需要恢复到之前的数，这时候机器肯定是没有存储它的，需要通过计算得到。

如何得到之前的数呢？

`[y]` 和 `[-y]` 互为相反数，因为上一步是加 `[-y]补` 得到的余数，那现在加 `[y]补` 得到之前的数(称为恢复余数)。

所以需要先把 `[y]补`，`[-y]补` 的机器码算出来
  - `[y]原 = 0.1101`，`[y]补 = 0.1101`，`[-y]补=1.0011` 

### 计算步骤

|步骤|操作|ACC|MQ|X|
|:--|:--|:--|:--|:--|
|1|被除数放置到 ACC 中，MQ 置 0|01011|00000|01101|
|2|MQ 商 1|01011|00001|01101|
|3|ACC - X = ACC + [-y]补 = 01011 + 10011|11110|00001|01101|
|4|ACC 是负数，ACC 需要恢复到之前的余数，ACC + [y]补 = 11110 + 01101，MQ 从 1 变成 0|01011|00000|01101|
|5|逻辑左移一位|10110|00000|01101|
|6|MQ 商 1|10110|00001|01101|
|7|ACC - X = ACC + [-y]补 = 10110 + 10011|01001|00001|01101|
|8|ACC 是正数，不需要恢复余数|01001|00001|01101|
|9|逻辑左移一位|10010|00010|01101|
|10|MQ 商 1|10010|00011|01101|
|11|ACC - X = ACC + [-y]补 = 10010 + 10011|00101|00011|01101|
|12|ACC 是正数，不需要恢复余数|00101|00011|01101|
|13|逻辑左移一位|01010|00110|01101|
|14|MQ 商 1|01010|00111|01101|
|15|ACC - X = ACC + [-y]补 = 01010 + 10011|11101|00111|01101|
|16|ACC 是负数，ACC 需要恢复到之前的余数，ACC + [y]补 = 11101 + 01101|01010|00110|01101|
|17|逻辑左移一位|10100|01100|01101|
|18|MQ 商 1|10100|01101|01101|
|19|ACC - X = ACC + [-y]补 = 10100 + 10011|00111|01101|01101|
|20|最终符号位：被除数的符号位 ⊕ 除数符号位 = 0 ⊕ 0 = 0|-|-|-|

第19步，如果计算的结果是负数，还是要再进行一步恢复余数，这里计算的结果是正数，所以就结束了，不再左移了。

这里逻辑左移了 `4` 次，上商 `5` 次，所以机器位数是 `n` 位，那么需要逻辑左移 `n` 次，上商 `n+1` 次

最终结果：
  - 商：`0.1101`
  - 余数：`0.00000111`

## 原码除法加减交替法(不恢复余数法)

最终运算结果，商在 `MQ` 中，商的位数是数值位位数；余数在 `ACC` 中，余数的位数是 `2^-n`；运算结果的符号位单独处理：被除数的符号位 ⊕ 除数符号位。

### 运算过程

`ACC - X = ACC + [-y]补` 的值如果是负数，那么我们会加上它相反数的补 `ACC + [y]补`，这一步被称为恢复余数。
  1. `ACC + [-y]补` 负数
  2. `ACC + [-y]补 + [y]补` 恢复余数
  3. `2(ACC + [-y]补 + [y]补)` 逻辑左移一位
  4. `2(ACC + [-y]补 + [y]补) - [y]补` 减除数

简化得 `2(ACC + [-y]补) + [y]补`
  - `ACC + [-y]补` 如果是负数的话，将 `MQ` 改商 `0`
  - 逻辑左移一位(`ACC` 和 `MQ` 都要逻辑左移)
  - `MQ` 商 `1`，并且加上除数 `[y]补`

### 计算步骤
|步骤|操作|ACC|MQ|X|
|:--|:--|:--|:--|:--|
|1|置 0|01011|00000|01101|
|2|MQ 商 1|01011|00001|01101|
|3|ACC - X = ACC + [-y]补 = 01011 + 10011|11110|00001|01101|
|4|ACC 是负数，MQ 改商 0|11110|00000|01101|
|5|逻辑左移一位|11100|00000|01101|
|6|MQ 商 1|11100|00001|01101|
|7|ACC + X = ACC + [y]补 = 11100 + 01101|01001|00001|01101|
|8|ACC 是正数，MQ 不用改|01001|00001|01101|
|9|逻辑左移一位|10010|00010|01101|
|10|MQ 商 1|10010|00011|01101|
|11|ACC - X = ACC + [-y]补 = 10010 + 10011|00101|00011|01101|
|12|ACC 是正数，MQ 不用改|00101|00011|01101|
|13|逻辑左移一位|01010|00110|01101|
|14|MQ 商 1|01010|00111|01101|
|15|ACC - X = ACC + [-y]补 = 01010 + 10011|11101|00111|01101|
|16|ACC 是负数，MQ 改商 0|11101|00110|01101|
|17|逻辑左移一位|11010|01100|01101|
|18|MQ 商 1|11010|01101|01101|
|19|ACC + X = ACC + [y]补 = 11010 + 01101|00111|01101|01101|
|20|最终符号位：被除数的符号位 ⊕ 除数符号位 = 0 ⊕ 0 = 0|-|-|-|

第19步，如果计算的结果是负数，`MQ` 还是要进行改商 `0`，并左移再加上 `[y]补`，和恢复余数法是一样的步骤。

这里逻辑左移了 `4` 次，上商 `5` 次，所以机器位数是 `n` 位，那么需要逻辑左移 `n` 次，上商 `n+1` 次

最终结果：
  - 商：`0.1101`
  - 余数：`0.0111 × 2^-4 = 0.00000111`

## 补码除法加减交替法

题目：`[x]原 = 0.1000，[y]原 = 1.1011，[y]补 = 1.0101，[-y]补 = 0.1011`

被除数和除数要用两位符号位：
  - `[x]原 = 00.1000`
  - `[y]原 = 11.1011`
  - `[y]补 = 11.0101`
  - `[-y]补 = 00.1011`

### 运算过程

判断被除数(余数)和除数的符号位
  1. 被除数和除数符号位判断
     - 同号，被除数减除数
     - 异号，被除数加除数
  2. 余数和除数符号位判断
     - 同号，`MQ` 商 `1`，`ACC` 和 `MQ` 逻辑左移一位，余数减除数
     - 异号，`MQ` 商 `0`，`ACC` 和 `MQ` 逻辑左移一位，余数加除数
  3. 循环第三步，循环的次数是机器位数

### 计算步骤

|步骤|操作|ACC|MQ|X|
|:--|:--|:--|:--|:--|
|1|置 0|001000|00000|110101|
|2|ACC + X = ACC + [y]补 = 001000 + 110101|111101|00000|110101|
|3|ACC 和 X 同号，MQ 商 1|111101|00001|110101|
|4|逻辑左移一位|111010|00010|110101|
|5|ACC - X = ACC + [-y]补 = 111010 + 001011|000101|00010|110101|
|6|ACC 和 X 异号，MQ 商 0|000101|00010|110101|
|7|逻辑左移一位|001010|00100|110101|
|8|ACC + X = ACC + [y]补 = 001010 + 110101|111111|00100|110101|
|9|ACC 和 X 同号，MQ 商 1|111111|00101|110101|
|10|逻辑左移一位|111110|01010|110101|
|11|ACC - X = ACC + [-y]补 = 111110 + 001011|001001|01010|110101|
|12|逻辑左移一位|010010|10100|110101|
|13|ACC + X = ACC + [y]补 = 010010 + 110101|000111|10100|110101|
|14|MQ 末尾横置 1|000111|10101|110101|
|15|最终符号位：ACC 中的符号位 00|-|-|-|

第14步最终计算的结果，末尾要横置 `1`，其精度误差 `2^-4`。

这里逻辑左移了 `4` 次，上商 `5` 次，所以机器位数是 `n` 位，那么需要逻辑左移 `n` 次，上商 `n+1` 次

最终结果：
  - 商：`1.0101`
  - 余数：`0.0111 × 2^-4 = 0.00000111`

## 总结

原码的除法运算和补码的除法运算的左移都是逻辑左移。

机器位数是 `n` 位，那么需要逻辑左移 `n` 次，上商 `n+1` 次，
  - 补码除法运算最后一步横置 `1`，其精度误差 `2^-4`