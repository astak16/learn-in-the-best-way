> ps 如无特殊说明，使用的是 `8` 位字长

两个机器数的加法运算：`00001110 + 10001110 = 10011100`

把这两个机器数看成是无符号数相加，那么他们的结果没有问题：
  - `00001110` -> `14`
  - `10001110` -> `142`
  - `10011100` -> `156`

把这两个数看成是有符号数相加，这就出现了问题：
  - `00001110` -> `14`
  - `10001110` -> `-14`
  - `10011100` ≠ `0`

如何修正这个问题呢？如果看到 `1` 开头的有符号数，取它的绝对值进行相加
  - `00001110` -> `14`
  - `-` `00001110` -> `-` `14`
  - `00000000` -> `0`

让计算机实现这样一个转换，成本是挺大的，有什么方法可以实现这点呢？

`0` 在在计算机中是 `00000000`，那现在有一个数 `100000000` 在 `8` 位计算机中是不是也是 `0`，因为它溢出了，最高位的 `1` 会被舍弃。

现在只要找到一个数和 `00001110` 相加，得到的结果是 `100000000`，舍弃高位不也等于 `0` 么。

用手动计算 `100000000 - 00001110` 得到 `11110010`。

`11110010` 和 `00001110` 之间的关系：
  1. `10001110` 和 `00001110` 之间的关系是互为相反数
  2. `10001110` 数值位取反得 `11110001`
  3. `11110001` 末尾 + `1` 得 `11110010`

在看补码的定义：如果符号位是 `1`，数值位取反，末尾 + `1`

这就实现了将减法运算转变成了加法运算。